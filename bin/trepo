#!/usr/bin/python3
# Copyright 2017 Samsung Electronics Co., Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import os
import re
import sys
import yaml
import trepo
import requests
import functools
import subprocess
from datetime import datetime
from argparse import (ArgumentParser,
                      RawTextHelpFormatter,
                      REMAINDER)
from bs4 import BeautifulSoup


# Version
__version__ = '0.1'
# Base URL
BASE_URL = 'http://download.tizen.org/snapshots/tizen/base/'
# Unified Build Snapshot URL
UB_URL = 'http://download.tizen.org/snapshots/tizen/unified/'
UBS_URL = UB_URL + '{version}/'
UBS_MANIFEST_URL = UBS_URL + 'builddata/manifest/{version}_{target}.xml'
UBS_BUILDXML_URL = UBS_URL + 'build.xml'
# Platform source URI
PLATFORM_URL = 'review.tizen.org'
PLATFORM_FETCH_URL = 'ssh://{url}/'.format(url=PLATFORM_URL)
# Configurations
REMOTE_NAME = 'origin'
TREPO_META_DIR = '.trepo'
TREPO_INFO = 'trepo_info'
REPO_CMD = '{}/repo'.format(trepo.__path__[0])
VERSION_PATTERN = '[0-9]{8}\.[0-9]{1,2}'
UBS_VERSION_PREFIX = 'tizen-unified_'
DATE_FORMAT_STR = '%a, %d %b %Y %X %Z'


# Helpers
def find_trepo_path():
    """Look for a trepo path, starting at the current directory."""
    curdir = os.getcwd()
    trepo_info = None

    olddir = None
    while curdir != '/' and curdir != olddir and not trepo_info:
        trepo_info = os.path.join(curdir, TREPO_META_DIR, TREPO_INFO)
        if not os.path.exists(trepo_info):
            trepo_info = None
            olddir = curdir
            curdir = os.path.dirname(curdir)
    # trepo workspace, trepo_info, trepo_metadir
    return (curdir, trepo_info, os.path.join(curdir, TREPO_META_DIR))


def review_ssh_config():
    """docstring for review_ssh_config"""
    ssh_warning = """Error: Can't find proper ssh config for review.tizen.org
Please add proper ssh host configuration in ~/.ssh/config file.

Example)
  Host review.tizen.org
    User '<Your Tizen account>'
    Port 29418
    Identityfile '<Your ssh private key path for review.tizen.org>'
"""
    try:
        with open(os.path.expanduser('~/.ssh/config'), 'r') as f:
            ssh_config = f.read()
    except FileNotFoundError:
        raise Exception(ssh_warning)

    if not re.findall(PLATFORM_URL, ssh_config):
        raise Exception(ssh_warning)


def load_yaml(filename):
    """Load yaml file"""
    with open(os.path.abspath(os.path.expanduser(filename)), 'r') as stream:
        data = yaml.load(stream)
    return data


def convert_snapshot_version(version='latest'):
    """Get a snapshot version string like tizen-unified_YYYYMMDD.N"""
    if version != 'latest':
        return '{}{}'.format(UBS_VERSION_PREFIX, version)
    url = UBS_BUILDXML_URL.format(version='latest')
    text = requests.get(url).text
    return re.findall('{}{}'.format(UBS_VERSION_PREFIX, VERSION_PATTERN),
                      text)[-1]


def get_manifest(version, target):
    """Get a manifest xml from remote http server"""
    url = UBS_MANIFEST_URL.format(version=version, target=target)
    resp = requests.get(url)
    if resp.status_code != 200:
        raise Exception('Can not access {}. '
                        'Is {} correct snapshot version?'.format(url, version))
    return resp.text


def find_base_repository_version(version):
    """Find a proper base rpm repository version to generate gbs.conf file"""
    base_soup = BeautifulSoup(requests.get(BASE_URL).text, 'html.parser')
    base_lms = []
    for base in base_soup.find_all('a', attrs={'href':
                                               re.compile(VERSION_PATTERN)}):
        base_build_xml = '{}{}build.xml'.format(BASE_URL, base['href'])
        lm_str = requests.get(base_build_xml).headers['Last-Modified']
        lm = datetime.strptime(lm_str, DATE_FORMAT_STR)
        base_lms.append((base['href'], lm))

    ubs_build_xml = UBS_BUILDXML_URL.format(version=version)
    ubs_lm_str = requests.get(ubs_build_xml).headers['Last-Modified']
    ubs_lm = datetime.strptime(ubs_lm_str, DATE_FORMAT_STR)

    for base in reversed(base_lms):
        if base[1] < ubs_lm:
            return base[0].strip('/')
    else:
        return base_lms[-1][0].strip('/')


def gen_gbs_conf(target_type, snapshot_version):
    """Gnerate a gbs conf and publish it to workspace"""
    with open('{}/gbs.conf.template'.format(trepo.__path__[0]), 'r') as f:
        gbs_conf_template = f.read()

    base_version = find_base_repository_version(snapshot_version)
    gbs_conf = gbs_conf_template.format(target_type=target_type,
                                        base_version=base_version,
                                        snapshot_version=snapshot_version)
    with open('{}/.gbs.conf'.format(find_trepo_path()[0]), 'w') as f:
        f.write(gbs_conf)


def subparser(func):
    """docstring for subparser"""
    @functools.wraps(func)
    def wrapper(parser):
        splitted = func.__doc__.split('\n')
        name = func.__name__.split('_')[0]
        subparser = parser.add_parser(name, help=splitted[0],
                                      description='\n'.join(splitted[1:]),
                                      formatter_class=RawTextHelpFormatter)
        subparser.set_defaults(module='cmd_{0}'.format(name))
        return func(subparser)
    return wrapper


# Command handlers
def cmd_init(args):
    """Initialize tizen repo in the current working directory"""
    manifest_text = """<?xml version="1.0" encoding="UTF-8"?>
<manifest>
  <remote fetch="{fetch_url}" name="{remote_name}"/>
  <default remote="{remote_name}"/>
</manifest>
""".format(fetch_url=PLATFORM_FETCH_URL, remote_name=REMOTE_NAME)
    manifest_soup = BeautifulSoup(manifest_text, 'xml')

    config_file = args.config_file
    snapshot_version = args.snapshot_version
    project_names = args.project_names
    target_type = args.target_type
    regex = args.regex

    # -f option has the highest priority
    if config_file:
        config = load_yaml(config_file)
        if 'snapshot_version' in config:
            snapshot_version = config['snapshot_version']
        if 'target_type' in config:
            target_type = config['target_type']
        if 'project_names' in config:
            project_names = config['project_names']
        if 'regex' in config:
            regex = config['regex']

    # Get manifest.xml from remote (download.tizen.org)
    snapshot_version = convert_snapshot_version(snapshot_version)
    print('snapshot version: {}'.format(snapshot_version))
    remote_manifest = get_manifest(snapshot_version, target_type)
    remote_soup = BeautifulSoup(remote_manifest, 'xml')

    if not project_names and not regex:
        projects = [p for p in remote_soup.find_all('project')]
    elif regex:
        projects = remote_soup.find_all('project', {'name': re.compile(regex)})
    else:
        if type(project_names) is str:
            project_names = [p.strip() for p in project_names.split(',')]
        projects = []
        for project_name in project_names:
            project = remote_soup.find('project',
                                       {'name': project_name.strip()})
            if not project:
                raise Exception('{} project does not exist in platform '
                                'manifest.'.format(project_name))
            projects.append(project)

    for project in projects:
        manifest_soup.manifest.append(project)

    # Create temporary git to keep manifest xml file
    manifest_dir = '{}/{}/manifest'.format(os.getcwd(), TREPO_META_DIR)
    git_cmd = ['git', 'init', manifest_dir]
    subprocess.call(git_cmd)

    with open('{manifest_dir}/'
              'default.xml'.format(manifest_dir=manifest_dir), 'w') as f:
        f.write(manifest_soup.prettify())

    temp_gitdir = '{manifest_dir}/.git'.format(manifest_dir=manifest_dir)
    subprocess.call(['git', '--git-dir', temp_gitdir, '--work-tree',
                     manifest_dir, 'add', 'default.xml'])
    subprocess.call(['git', '--git-dir', temp_gitdir, '--work-tree',
                     manifest_dir, 'commit', '-m', 'Update manifest'])
    repo_base_cmd = [REPO_CMD, 'init',
                     '-u', manifest_dir,
                     '--repo-url',
                     '{}/git-repo.git'.format(trepo.__path__[0]),
                     '--repo-branch', 'stable',
                     '--quiet',
                     '--no-repo-verify']

    if args.config_name:
        repo_base_cmd.append('--config-name')

    subprocess.call(repo_base_cmd)

    # Save trepo info
    with open('{}/{}'.format(TREPO_META_DIR, TREPO_INFO), 'w') as f:
        yaml.dump({'snapshot_version': snapshot_version,
                   'target_type': target_type,
                   'project_names': [project['name']
                                     for project in projects]},
                  f)


def cmd_sync(args):
    """Update working tree to the tizen repo snapshot"""
    review_ssh_config()
    # Repo sync
    try:
        trepo_info = load_yaml(find_trepo_path()[1])
        snapshot_version = trepo_info['snapshot_version']
        repo_sync_cmd = [REPO_CMD, 'sync']

        if args.force_broken:
            repo_sync_cmd.append('-f')
        if args.jobs:
            repo_sync_cmd.extend(['-j', str(args.jobs)])
        subprocess.call(repo_sync_cmd)

        # Create a topic branch
        repo_start_cmd = [REPO_CMD, 'start', '--all', snapshot_version]
        subprocess.call(repo_start_cmd)

        # Generate gbs.conf.
        gen_gbs_conf(trepo_info['target_type'], snapshot_version)

    except Exception:
        subprocess.call([REPO_CMD, 'sync'])


def cmd_status(args):
    """Show the working tree status"""
    status_cmd = [REPO_CMD, 'status']
    if args.jobs:
        status_cmd.extend(['-j', str(args.jobs)])
    if args.orphans:
        status_cmd.append('-o')
    subprocess.call(status_cmd)


def cmd_info(args):
    """Get info on the manifest branch, current branch or unmerged branches"""
    try:
        trepo_info = load_yaml(find_trepo_path()[1])
        snapshot_version = trepo_info['snapshot_version']
        target_type = trepo_info['target_type']
        project_names = trepo_info['project_names']
        print('tizen repo snapshot version: {}'.format(snapshot_version))
        print('tizen repo target type: {}'.format(target_type))
        print('tizen repo project names:')
        for project_name in project_names:
            print('  {}'.format(project_name))
    except Exception:
        pass
    info_cmd = [REPO_CMD, 'info']
    if args.overview:
        info_cmd.append('-o')
    subprocess.call(info_cmd)


def cmd_forall(args):
    """Run a shell command in each project"""
    forall_cmd = [REPO_CMD, 'forall']
    if args.project:
        forall_cmd.extend(args.project)
    if args.regex:
        forall_cmd.append('-r')
        forall_cmd.extend(args.regex)
    if args.inverse_regex:
        forall_cmd.append('-i')
        forall_cmd.extend(args.inverse_regex)
    if args.abort_on_errors:
        forall_cmd.append('-e')
    if args.project_header:
        forall_cmd.append('-p')
    if args.verbose:
        forall_cmd.append('-v')
    if args.jobs:
        forall_cmd.extend(['-j', str(args.jobs)])
    if args.command:
        forall_cmd.append('-c')
        forall_cmd.extend(args.command)
    subprocess.call(forall_cmd)


def cmd_snapshots(args):
    """Get version list of tizen unified build snapshot"""
    resp = requests.get(UB_URL)
    if resp.status_code != 200:
        raise Exception('Can not access {}. '
                        'Is {} correct url?'.format(UB_URL))
    soup = BeautifulSoup(resp.text, 'html.parser')
    snapshots = soup.find_all('a', attrs={'href': re.compile(VERSION_PATTERN)})
    print('List of tizen unified build snapshots')
    for s in reversed(snapshots):
        print('  {}'.format(s['href'].strip('/')[len(UBS_VERSION_PREFIX):]))


# Sub parsers
@subparser
def init_parser(parser):
    """Initialize tizen repo in the current working directory"""

    # trepo
    group = parser.add_argument_group('trepo options')
    group.add_argument('-s', '--snapshot-version',
                       dest='snapshot_version',
                       help='Initialize tizen repo with specific snapshot '
                            'version (YYYYMMDD.N). Default snapshot version'
                            ' is "latest".',
                       default='latest',
                       metavar='SNAPSHOT')
    group.add_argument('-t', '--target-type',
                       dest='target_type',
                       help='Get project lists from specific target manifest '
                            '(standard/emulator). '
                            'Default target type is "standard".',
                       metavar='TARGETTYPE',
                       default='standard')
    group.add_argument('-p', '--project-names',
                       dest='project_names',
                       help='Initialize tizen repo with specific project names'
                            '(Each project names are separated by comma). '
                            'Initialize repo with all project sources '
                            'if this argument is None.',
                       metavar='PACKAGENAMES')
    group.add_argument('-f', '--config-file',
                       dest='config_file',
                       help='Initialize tizen repo from yaml config file.',
                       metavar='CONFIGFILE')
    group.add_argument('-r', '--regex',
                       dest='regex',
                       help='Initialize tizen repo with projects matching'
                            'this regular expression.',
                       metavar='REGEX')
    # Other
    group = parser.add_argument_group('Other options')
    group.add_argument('--config-name',
                       dest='config_name', action="store_true", default=False,
                       help='Always prompt for name/e-mail')


@subparser
def sync_parser(parser):
    """Update working tree to the tizen repo snapshot"""
    parser.add_argument('-f', '--force-broken',
                        dest='force_broken', action='store_true',
                        help="continue sync even if a project fails to sync")
    parser.add_argument('-j', '--jobs',
                        dest='jobs', action='store', type=int, default=4,
                        help="projects to fetch simultaneously (default 4)")


@subparser
def status_parser(parser):
    """Show the working tree status"""
    parser.add_argument('-j', '--jobs',
                        dest='jobs', action='store', type=int, default=2,
                        help="number of projects to check simultaneously")
    parser.add_argument('-o', '--orphans',
                        dest='orphans', action='store_true',
                        help="include objects in working directory outside of"
                             " repo projects")


@subparser
def info_parser(parser):
    """Get info on the manifest branch, current branch or unmerged branches"""
    parser.add_argument('-o', '--overview',
                        dest='overview', action='store_true',
                        help='show overview of all local commits')


@subparser
def forall_parser(parser):
    """Run a shell command in each project"""
    parser.add_argument('project', nargs='*',
                        help="Project names")
    parser.add_argument('-r', '--regex',
                        dest='regex', nargs='+',
                        help="Execute the command only on projects matching"
                             " regex or wildcard expression")
    parser.add_argument('-i', '--inverse-regex',
                        dest='inverse_regex', nargs='+',
                        help="Execute the command only on projects not"
                             " matching regex or wildcard expression")
    parser.add_argument('-c', '--command',
                        help='Command (and arguments) to execute',
                        dest='command',
                        nargs=REMAINDER,
                        type=str)
    parser.add_argument('-e', '--abort-on-errors',
                        dest='abort_on_errors', action='store_true',
                        help='Abort if a command exits unsuccessfully')

    group = parser.add_argument_group('Output')
    group.add_argument('-p',
                       dest='project_header', action='store_true',
                       help='Show project headers before output')
    group.add_argument('-v', '--verbose',
                       dest='verbose', action='store_true',
                       help='Show command error messages')
    group.add_argument('-j', '--jobs',
                       dest='jobs', action='store', type=int, default=1,
                       help='number of commands to execute simultaneously')


@subparser
def snapshots_parser(parser):
    """Get version list of tizen unified build snapshot"""
    pass


# Main function
def main(argv):
    """docstring for main"""
    description = """Tizen repo is a wrapper of git-repo.
This wrapper helps users can init and sync tizen source code more easily.
"""
    parser = ArgumentParser(description=description)

    parser.add_argument('-V', '--version',
                        action='version',
                        version='%(prog)s ' + __version__)

    parser.format_usage = parser.format_help
    subparsers = parser.add_subparsers(title='subcommands',
                                       dest='subcommands')
    subparsers.required = True
    for name, obj in sorted(globals().items()):
        if name.endswith('_parser') and callable(obj):
            obj(subparsers)

    args = parser.parse_args(argv)

    globals()[args.module](args)

try:
    sys.exit(main(sys.argv[1:]))
except Exception as e:
    print(e)
    sys.exit(-1)
